{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/logger.ts"],"sourcesContent":["\n\n\n/**\n * Edge ve Node 18+ uyumlu SHA-256 hex hash fonksiyonu\n * Web Crypto API kullanır, sync fallback yoktur.\n */\nexport async function hashIdempotencyKey(key: string): Promise<string> {\n  if (!key) return '';\n  const encoder = new TextEncoder();\n  const data = encoder.encode(key);\n  // globalThis.crypto hem Node 18+ hem Edge'de mevcut\n  const hashBuffer = await globalThis.crypto.subtle.digest('SHA-256', data);\n  // Buffer'dan hex string'e çevir\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  const hex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n  return hex.slice(0, 12);\n}\n\nasync function redact(obj: any): Promise<any> {\n  if (!obj || typeof obj !== 'object') return obj;\n  const out: any = Array.isArray(obj) ? [] : {};\n  for (const k in obj) {\n    if (k.toLowerCase().includes('jwt')) {\n      out[k] = '[REDACTED]';\n    } else if (k === 'idempotencyKey') {\n      out[k] = await hashIdempotencyKey(obj[k]);\n    } else if (typeof obj[k] === 'object') {\n      out[k] = await redact(obj[k]);\n    } else {\n      out[k] = obj[k];\n    }\n  }\n  return out;\n}\n\n\ntype LogContext = {\n  requestId?: string;\n  userId?: string;\n  ip?: string;\n  [key: string]: any;\n};\n\nexport async function log(level: string, event: string, payload: object, context?: LogContext) {\n  const entry = {\n    timestamp: new Date().toISOString(),\n    level,\n    event,\n    ...context,\n    payload: await redact(payload),\n  };\n  // eslint-disable-next-line no-console\n  console.log(JSON.stringify(entry));\n}\n\nexport function logInfo(event: string, payload: object, context?: LogContext) {\n  log('info', event, payload, context);\n}\nexport function logWarn(event: string, payload: object, context?: LogContext) {\n  log('warn', event, payload, context);\n}\nexport function logError(event: string, payload: object, context?: LogContext) {\n  log('error', event, payload, context);\n}\n"],"names":[],"mappings":"AAGA;;;CAGC;;;;;;;;;;;;AACM,eAAe,mBAAmB,GAAW;IAClD,IAAI,CAAC,KAAK,OAAO;IACjB,MAAM,UAAU,IAAI;IACpB,MAAM,OAAO,QAAQ,MAAM,CAAC;IAC5B,oDAAoD;IACpD,MAAM,aAAa,MAAM,WAAW,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,WAAW;IACpE,gCAAgC;IAChC,MAAM,YAAY,MAAM,IAAI,CAAC,IAAI,WAAW;IAC5C,MAAM,MAAM,UAAU,GAAG,CAAC,CAAA,IAAK,EAAE,QAAQ,CAAC,IAAI,QAAQ,CAAC,GAAG,MAAM,IAAI,CAAC;IACrE,OAAO,IAAI,KAAK,CAAC,GAAG;AACtB;AAEA,eAAe,OAAO,GAAQ;IAC5B,IAAI,CAAC,OAAO,OAAO,QAAQ,UAAU,OAAO;IAC5C,MAAM,MAAW,MAAM,OAAO,CAAC,OAAO,EAAE,GAAG,CAAC;IAC5C,IAAK,MAAM,KAAK,IAAK;QACnB,IAAI,EAAE,WAAW,GAAG,QAAQ,CAAC,QAAQ;YACnC,GAAG,CAAC,EAAE,GAAG;QACX,OAAO,IAAI,MAAM,kBAAkB;YACjC,GAAG,CAAC,EAAE,GAAG,MAAM,mBAAmB,GAAG,CAAC,EAAE;QAC1C,OAAO,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,UAAU;YACrC,GAAG,CAAC,EAAE,GAAG,MAAM,OAAO,GAAG,CAAC,EAAE;QAC9B,OAAO;YACL,GAAG,CAAC,EAAE,GAAG,GAAG,CAAC,EAAE;QACjB;IACF;IACA,OAAO;AACT;AAUO,eAAe,IAAI,KAAa,EAAE,KAAa,EAAE,OAAe,EAAE,OAAoB;IAC3F,MAAM,QAAQ;QACZ,WAAW,IAAI,OAAO,WAAW;QACjC;QACA;QACA,GAAG,OAAO;QACV,SAAS,MAAM,OAAO;IACxB;IACA,sCAAsC;IACtC,QAAQ,GAAG,CAAC,KAAK,SAAS,CAAC;AAC7B;AAEO,SAAS,QAAQ,KAAa,EAAE,OAAe,EAAE,OAAoB;IAC1E,IAAI,QAAQ,OAAO,SAAS;AAC9B;AACO,SAAS,QAAQ,KAAa,EAAE,OAAe,EAAE,OAAoB;IAC1E,IAAI,QAAQ,OAAO,SAAS;AAC9B;AACO,SAAS,SAAS,KAAa,EAAE,OAAe,EAAE,OAAoB;IAC3E,IAAI,SAAS,OAAO,SAAS;AAC/B"}},
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/rate-limit.ts"],"sourcesContent":["/**\n * Rate limiting utility for protecting endpoints\n * Supports Redis-based limiter when REDIS_URL present, otherwise falls back to in-memory store\n */\n\ninterface RateLimitEntry {\n  count: number;\n  resetTime: number;\n}\n\nclass InMemoryStore {\n  private store = new Map<string, RateLimitEntry>();\n\n  check(key: string, maxRequests: number, windowMs: number): boolean {\n    const now = Date.now();\n    const entry = this.store.get(key);\n\n    if (!entry || now > entry.resetTime) {\n      this.store.set(key, { count: 1, resetTime: now + windowMs });\n      return true;\n    }\n\n    if (entry.count < maxRequests) {\n      entry.count++;\n      return true;\n    }\n\n    return false;\n  }\n\n  getResetTime(key: string): number {\n    const entry = this.store.get(key);\n    if (!entry) return 0;\n    const resetIn = Math.ceil((entry.resetTime - Date.now()) / 1000);\n    return Math.max(0, resetIn);\n  }\n\n  cleanup(): void {\n    const now = Date.now();\n    for (const [key, entry] of this.store.entries()) {\n      if (now > entry.resetTime) this.store.delete(key);\n    }\n  }\n}\n\nconst memoryStore = new InMemoryStore();\n\n/**\n * Attempt to use Redis if available and safe (not edge runtime).\n */\nasync function tryUseRedis() {\n  if (!process.env.REDIS_URL) return null;\n  // Avoid importing redis/ioredis in Edge runtime where it breaks\n  if (process.env.NEXT_RUNTIME === 'edge') return null;\n\n  try {\n    const Redis = (await import('ioredis')).default;\n    return new Redis(process.env.REDIS_URL as string);\n  } catch (err) {\n    return null;\n  }\n}\n\n/**\n * Check rate limit for a key. Returns true if allowed.\n */\nexport async function checkRateLimit(key: string, maxRequests: number, windowMs: number): Promise<boolean> {\n  const redisUrl = process.env.REDIS_URL;\n  if (redisUrl && process.env.NEXT_RUNTIME !== 'edge') {\n    const client = await tryUseRedis();\n    if (client) {\n      try {\n        const windowSec = Math.ceil(windowMs / 1000);\n        const val = await client.incr(key);\n        if (val === 1) {\n          await client.expire(key, windowSec);\n        }\n        // close client to avoid hanging connections in short-lived processes\n        await client.quit();\n        return val <= maxRequests;\n      } catch (e) {\n        // fall back to memory on any redis error\n        return memoryStore.check(key, maxRequests, windowMs);\n      }\n    }\n  }\n\n  return memoryStore.check(key, maxRequests, windowMs);\n}\n\nexport async function getResetTime(key: string): Promise<number> {\n  const redisUrl = process.env.REDIS_URL;\n  if (redisUrl && process.env.NEXT_RUNTIME !== 'edge') {\n    const client = await tryUseRedis();\n    if (client) {\n      try {\n        const ttl = await client.ttl(key);\n        await client.quit();\n        return Math.max(0, ttl);\n      } catch (e) {\n        return memoryStore.getResetTime(key);\n      }\n    }\n  }\n\n  return memoryStore.getResetTime(key);\n}\n\n// Cleanup memory store periodically\nsetInterval(() => memoryStore.cleanup(), 60000);\n\n/**\n * Get rate limit key from IP and endpoint\n */\nexport function getRateLimitKey(ip: string, endpoint: string): string {\n  return `${ip}:${endpoint}`;\n}\n\n/**\n * Extract client IP from headers\n */\nexport function getClientIP(headers: {\n  'x-forwarded-for'?: string;\n  'cf-connecting-ip'?: string;\n  'x-real-ip'?: string;\n}): string {\n  const forwarded = headers['x-forwarded-for'];\n  if (typeof forwarded === 'string') {\n    return forwarded.split(',')[0].trim();\n  }\n\n  const cfip = headers['cf-connecting-ip'];\n  if (typeof cfip === 'string') {\n    return cfip;\n  }\n\n  const realip = headers['x-real-ip'];\n  if (typeof realip === 'string') {\n    return realip;\n  }\n\n  return '127.0.0.1';\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;AAOD,MAAM;IACI,QAAQ,IAAI,MAA8B;IAElD,MAAM,GAAW,EAAE,WAAmB,EAAE,QAAgB,EAAW;QACjE,MAAM,MAAM,KAAK,GAAG;QACpB,MAAM,QAAQ,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;QAE7B,IAAI,CAAC,SAAS,MAAM,MAAM,SAAS,EAAE;YACnC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK;gBAAE,OAAO;gBAAG,WAAW,MAAM;YAAS;YAC1D,OAAO;QACT;QAEA,IAAI,MAAM,KAAK,GAAG,aAAa;YAC7B,MAAM,KAAK;YACX,OAAO;QACT;QAEA,OAAO;IACT;IAEA,aAAa,GAAW,EAAU;QAChC,MAAM,QAAQ,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;QAC7B,IAAI,CAAC,OAAO,OAAO;QACnB,MAAM,UAAU,KAAK,IAAI,CAAC,CAAC,MAAM,SAAS,GAAG,KAAK,GAAG,EAAE,IAAI;QAC3D,OAAO,KAAK,GAAG,CAAC,GAAG;IACrB;IAEA,UAAgB;QACd,MAAM,MAAM,KAAK,GAAG;QACpB,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,GAAI;YAC/C,IAAI,MAAM,MAAM,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;QAC/C;IACF;AACF;AAEA,MAAM,cAAc,IAAI;AAExB;;CAEC,GACD,eAAe;IACb,IAAI,CAAC,QAAQ,GAAG,CAAC,SAAS,EAAE,OAAO;IACnC,gEAAgE;IAChE,wCAAyC,OAAO;;;AAQlD;AAKO,eAAe,eAAe,GAAW,EAAE,WAAmB,EAAE,QAAgB;IACrF,MAAM,WAAW,QAAQ,GAAG,CAAC,SAAS;IACtC;;IAmBA,OAAO,YAAY,KAAK,CAAC,KAAK,aAAa;AAC7C;AAEO,eAAe,aAAa,GAAW;IAC5C,MAAM,WAAW,QAAQ,GAAG,CAAC,SAAS;IACtC;;IAaA,OAAO,YAAY,YAAY,CAAC;AAClC;AAEA,oCAAoC;AACpC,YAAY,IAAM,YAAY,OAAO,IAAI;AAKlC,SAAS,gBAAgB,EAAU,EAAE,QAAgB;IAC1D,OAAO,GAAG,GAAG,CAAC,EAAE,UAAU;AAC5B;AAKO,SAAS,YAAY,OAI3B;IACC,MAAM,YAAY,OAAO,CAAC,kBAAkB;IAC5C,IAAI,OAAO,cAAc,UAAU;QACjC,OAAO,UAAU,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI;IACrC;IAEA,MAAM,OAAO,OAAO,CAAC,mBAAmB;IACxC,IAAI,OAAO,SAAS,UAAU;QAC5B,OAAO;IACT;IAEA,MAAM,SAAS,OAAO,CAAC,YAAY;IACnC,IAAI,OAAO,WAAW,UAAU;QAC9B,OAAO;IACT;IAEA,OAAO;AACT"}},
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/middleware.ts"],"sourcesContent":["import { NextResponse, type NextRequest } from 'next/server';\nimport { logInfo } from './lib/logger';\nimport { getRateLimitKey, getClientIP, checkRateLimit, getResetTime } from './lib/rate-limit';\n\n/**\n * Middleware for Next.js App Router\n * Handles:\n * - Rate limiting for sensitive endpoints\n * - Request logging\n * - Security headers\n * \n * For endpoint-specific rate limits, see individual route handlers\n */\nexport async function middleware(request: NextRequest) {\n  const pathname = request.nextUrl.pathname;\n  const method = request.method;\n\n  // Get client IP for rate limiting\n  const clientIP = getClientIP({\n    'x-forwarded-for': request.headers.get('x-forwarded-for') || undefined,\n    'cf-connecting-ip':\n      request.headers.get('cf-connecting-ip') || undefined,\n    'x-real-ip': request.headers.get('x-real-ip') || undefined,\n  });\n\n  // Log request\n  logRequest(pathname, method, clientIP);\n\n  // Apply endpoint-specific rate limits\n  if (pathname.startsWith('/api/loyalty/claimReward')) {\n    const maxRequests = parseInt(\n      process.env.CLAIM_RATE_LIMIT_MAX || '10',\n      10\n    );\n    const windowMs = parseInt(\n      process.env.CLAIM_RATE_LIMIT_WINDOW || '60000',\n      10\n    );\n\n    const key = getRateLimitKey(clientIP, 'claim');\n    const allowed = await checkRateLimit(key, maxRequests, windowMs);\n\n    if (!allowed) {\n      const remaining = await getResetTime(key);\n      return new NextResponse(\n        JSON.stringify({\n          success: false,\n          error: 'Çok fazla istek. Lütfen daha sonra tekrar deneyin.',\n          retryAfter: remaining,\n        }),\n        {\n          status: 429,\n          headers: {\n            'Retry-After': remaining.toString(),\n            'Content-Type': 'application/json',\n          },\n        }\n      );\n    }\n  }\n\n  if (pathname.startsWith('/api/scan')) {\n    const maxRequests = parseInt(\n      process.env.SCAN_RATE_LIMIT_MAX || '20',\n      10\n    );\n    const windowMs = parseInt(\n      process.env.SCAN_RATE_LIMIT_WINDOW || '60000',\n      10\n    );\n\n    const key = getRateLimitKey(clientIP, 'scan');\n    const allowed = await checkRateLimit(key, maxRequests, windowMs);\n\n    if (!allowed) {\n      const remaining = await getResetTime(key);\n      return new NextResponse(\n        JSON.stringify({\n          success: false,\n          error: 'Çok fazla istek. Lütfen daha sonra tekrar deneyin.',\n          retryAfter: remaining,\n        }),\n        {\n          status: 429,\n          headers: {\n            'Retry-After': remaining.toString(),\n            'Content-Type': 'application/json',\n          },\n        }\n      );\n    }\n  }\n\n  // Let request proceed\n  const response = NextResponse.next();\n\n  // Add security headers (Helmet-like)\n  response.headers.set('X-Content-Type-Options', 'nosniff');\n  response.headers.set('X-Frame-Options', 'DENY');\n  response.headers.set('Referrer-Policy', 'no-referrer-when-downgrade');\n  response.headers.set('Permissions-Policy', 'geolocation=(), microphone=()');\n  response.headers.set('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');\n\n  // Content Security Policy - conservative default, allow self and required origins\n  const csp = [\n    \"default-src 'self'\",\n    \"script-src 'self' 'unsafe-inline'\",\n    \"style-src 'self' 'unsafe-inline'\",\n    \"img-src 'self' data:\",\n    \"connect-src 'self' ws:\",\n  ].join('; ');\n  response.headers.set('Content-Security-Policy', csp);\n\n  // CORS headers (adjust CORS_ORIGIN in .env)\n  const corsOrigin = process.env.CORS_ORIGIN || 'http://localhost:3000';\n  response.headers.set('Access-Control-Allow-Origin', corsOrigin);\n  response.headers.set('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');\n  response.headers.set('Access-Control-Allow-Headers', 'Content-Type,Authorization');\n  response.headers.set('Access-Control-Allow-Credentials', 'true');\n\n  // Handle preflight requests quickly\n  if (request.method === 'OPTIONS') {\n    return new NextResponse(null, { status: 204, headers: response.headers });\n  }\n\n  return response;\n}\n\n/**\n * Configure which routes should use middleware\n * Exclude static files, images, etc.\n */\nexport const config = {\n  matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],\n};\n\n/**\n * Simple request logging\n */\nfunction logRequest(pathname: string, method: string, ip: string) {\n  if (process.env.NODE_ENV !== 'test') {\n    logInfo('INCOMING_REQUEST', { path: pathname, method, ip });\n  }\n}\n"],"names":[],"mappings":"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"}}]
}